struct Plane
{
	vec3 normal;
	float distance;
};

struct Frustum
{
	Plane planes[4];
};


float getDistance(Plane plane, vec3 point)
{
	return dot(point, plane.normal) - plane.distance;
}

bool TouchesPlane(Plane plane, vec3 point)
{
	return getDistance(plane, point) < 0;
}

Plane MakePlane(vec3 a, vec3 b, vec3 c)
{
	Plane dummy;
	vec3 ba = normalize(b - a);
	vec3 ca = normalize(c - a);
	dummy.normal = normalize(cross(ba, ca));
	dummy.distance = dot(dummy.normal, a);
	return dummy;
}

bool SphereBehindPlane(Plane plane, vec4 sphere)
{
	return getDistance(plane, sphere.xyz) < -sphere.w;
}

bool SphereBehindPlaneExact(Plane plane, vec4 sphere)
{
	return getDistance(plane, sphere.xyz) < -sphere.w;
}

bool SphereTouchesPlane(Plane plane, vec4 sphere)
{
	return getDistance(plane, sphere.xyz) < sphere.w;
}

// Does the frustum contain the sphere?
bool FrustumSphere(Frustum frustum, vec4 sphere)
{
	bool result = true;
	for (uint i = 0; i < 4 && result; i++)
	{
		if (SphereBehindPlane(frustum.planes[i], sphere))
		{
			result = false;
		}
	}
	return result;
}

struct Cone
{
	vec3 position;
	float height;
	vec3 forward;
	float radius;
};

bool ConePlane(Cone cone, Plane plane)
{
	vec3 parallel = cross(cross(plane.normal, cone.forward), cone.forward);
	vec3 closest  = cone.position + cone.forward * cone.height - parallel * cone.radius;
	return TouchesPlane(plane, cone.position) && TouchesPlane(plane, closest);
}

bool FrustumCone(Frustum frustum, Cone cone, float zNear, float zFar)
{
	bool shouldInclude = true;
	Plane near = {vec3(0, 0, -1), zNear};
	Plane far = {vec3(0,  0,  1), zFar};
	if (ConePlane(cone, near) || ConePlane(cone, far))
	{
		shouldInclude = false;
	}
	
	for (uint i = 0; i < 4 && shouldInclude; i++)
	{
		if (ConePlane(cone, frustum.planes[i]))
		{
			shouldInclude = false;
		}
	}
	return shouldInclude;
}


layout(std430, binding = 5) volatile buffer Frustums
{
	Frustum frustums[];
};