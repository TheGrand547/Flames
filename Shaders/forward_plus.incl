layout(origin_upper_left) in vec4 gl_FragCoord;

float ConeRatio(Cone cone, vec3 forward)
{
	float angle = dot(cone.forward, -forward);
	// Flipping this does really neat things, if you transpose the normal and position in the cone light functions
	//return (cone.angle < angle) ? 1.f : 0.f;
	
	float temp = mix(cone.angle, 1.f, 0.5f);
	return smoothstep(cone.angle, temp, angle);
}

vec3 ConeLight(LightInfoBig light, FragData fragData)
{
	Cone cone = LightToCone(light);
	vec3 fragPosition  = fragData.position;
	vec3 fragNormal    = fragData.normal;
	vec3 viewDirection = fragData.viewDirection;
	
	vec3 lightDirection = normalize(cone.position - fragPosition);
	float distance = length(cone.position - fragPosition);
	
	// Do the attenuation thing
	float diffuse = applyDiffuse(fragData, lightDirection);
	float specular = applySpecular(fragData, lightDirection);
	
	float fallOff = attenuate(light.constants.xyz, distance);
	
	if (length(dot((cone.position - fragPosition), -cone.forward)) > cone.height)
	{
		fallOff = 0.f;
	}
	
	return light.color.xyz * (diffuse + specular) * ConeRatio(cone, lightDirection) * fallOff;
}

vec3 ApplyLight(LightInfoBig current, FragData fragData)
{
	vec3 lightOut = vec3(0);
	float type = current.position.w;
	// Point light
	if (type > 0)
	{
		lightOut = PointLightStruct(current, fragData);
	}
	// Light cone
	else if (type < 0)
	{
		lightOut = ConeLight(current, fragData);
	}
	return lightOut;
} 

vec3 ForwardPlusLighting(FragData fragData)
{
	const float ambient = 0.15;
	vec3 lightOut = vec3(ambient);

	vec2 index = floor((gl_FragCoord.xy) / TileSize);
	uint gridIndex = uint(index.x + index.y * tileDimension.x);
	
	const uint numLightsThisTile = tileMasks[gridIndex * MasksPerTile];
	uint processedLights = 0;
	
	// Possibly something with the bitCount() function to escape early if the number of lights remaining is zero
	uint firstMask = gridIndex * MasksPerTile + 1;
	for (uint i = 0; i + 1 < MasksPerTile && processedLights < numLightsThisTile; i++)
	{
		uint currentMask = tileMasks[i + firstMask];
		processedLights += bitCount(currentMask);
		while (currentMask != 0)
		{
			uint currentBit = findLSB(currentMask);
			currentMask ^= 1 << currentBit;
			lightOut += ApplyLight(lightsOriginal[32 * i + currentBit], fragData);		
		}
	}
	
	
	/*
	uvec2 lightData = grid[gridIndex];
	for (uint i = 0; i < lightData.y; i++)
	{
		uint index = indicies[i + lightData.x];
		// This applies lighting in world space
		lightOut += ApplyLight(lightsOriginal[index], fragData);

	}
	*/
	return lightOut;
}

vec3 LightTesting()
{
	const float ambient = 0.15;
	vec3 lightOut = vec3(ambient);

	vec2 index = floor((gl_FragCoord.xy) / TileSize);
	uint gridIndex = uint(index.x + index.y * tileDimension.x);

	uint numLightsThisTile = tileMasks[gridIndex * MasksPerTile];
	
	if (numLightsThisTile > 10)
	{
		return ambient + vec3(0, 1.f, 0);
	}
	return ambient + vec3(numLightsThisTile / 10.f);
};

vec3 ForwardPlusLightingViewSpace(FragData fragData)
{
	const float ambient = 0.15;
	vec3 lightOut = vec3(ambient);

	vec2 index = floor((gl_FragCoord.xy) / TileSize);
	uint gridIndex = uint(index.x + index.y * tileDimension.x);
	uvec2 lightData = grid[gridIndex];
	
	const uint numLightsThisTile = tileMasks[gridIndex * MasksPerTile];
	uint processedLights = 0;
	
	// Possibly something with the bitCount() function to escape early if the number of lights remaining is zero
	uint firstMask = gridIndex * MasksPerTile + 1;
	for (uint i = 0; i + 1 < MasksPerTile && processedLights < numLightsThisTile; i++)
	{
		uint currentMask = tileMasks[i + firstMask];
		processedLights += bitCount(currentMask);
		while (currentMask != 0)
		{
			uint currentBit = findLSB(currentMask);
			currentMask ^= 1 << currentBit;
			lightOut += ApplyLight(lights[32 * i + currentBit], fragData);		
		}
	}
	return lightOut;
}