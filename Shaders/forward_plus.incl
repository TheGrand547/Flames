layout(origin_upper_left) in vec4 gl_FragCoord;

float ConeRatio(Cone cone, vec3 forward)
{
	float angle = dot(cone.forward, -forward);
	return angle;
}

vec3 ConeLight(LightInfoBig light, vec3 fragPosition, vec3 fragNormal, vec3 viewDirection)
{
	Cone cone = LightToCone(light);
	vec3 lightDirection = cone.position - fragPosition;
	float distance = length(lightDirection);
	lightDirection /= distance;
	// Do the attenuation thing
	float diffuse = max(dot(lightDirection, fragNormal), 0);
	float specular = 0;
	
	vec3 lightConstants = light.constants.xyz;
	float fallOff = 1.0 / (lightConstants.x + lightConstants.y * distance + lightConstants.z * distance * distance);
	return light.color.xyz * (diffuse + specular) * ConeRatio(cone, lightDirection) * fallOff;
}

vec3 ApplyLight(LightInfoBig current, vec3 fragPosition, vec3 fragNormal, vec3 viewDirection)
{
	vec3 lightOut = vec3(0);
	float type = current.position.w;
	// Point light
	if (type > 0)
	{
		if (length(current.position.xyz - fragPosition) < current.position.w)
		{
			lightOut = PointLightStruct(current, fragNormal, fragPosition, viewDirection);
		}
	}
	// Light cone
	else if (type < 0)
	{
		lightOut = ConeLight(current, fragNormal, fragPosition, viewDirection);
	}
	return lightOut;
} 

vec3 ForwardPlusLighting(vec3 fragPosition, vec3 fragNormal, vec3 viewDirection)
{
	const float ambient = 0.15;
	vec3 lightOut = vec3(ambient);

	vec2 index = floor((gl_FragCoord.xy) / TileSize);
	uint gridIndex = uint(index.x + index.y * tileDimension.x);
	uvec2 lightData = grid[gridIndex];
	
	for (uint i = 0; i < lightData.y; i++)
	{
		uint index = indicies[i + lightData.x];
		LightInfoBig current = lightsOriginal[index];
		
		lightOut += ApplyLight(current, fragPosition, fragNormal, viewDirection);
	}
	return lightOut;
}

vec3 LightTesting()
{
	const float ambient = 0.15;
	vec3 lightOut = vec3(ambient);

	vec2 index = floor((gl_FragCoord.xy) / TileSize);
	uint gridIndex = uint(index.x + index.y * tileDimension.x);
	uvec2 lightData = grid[gridIndex];
	
	if (lightData.y > 10)
	{
		return ambient + vec3(0, 1.f, 0);
	}
	return ambient + vec3(lightData.y / 10.f);
};

vec3 ForwardPlusLightingViewSpace(vec3 fragPosition, vec3 fragNormal, vec3 viewDirection)
{
	const float ambient = 0.15;
	vec3 lightOut = vec3(ambient);

	vec2 index = floor((gl_FragCoord.xy) / TileSize);
	uint gridIndex = uint(index.x + index.y * tileDimension.x);
	uvec2 lightData = grid[gridIndex];
	
	for (uint i = 0; i < lightData.y; i++)
	{
		uint index = indicies[i + lightData.x];
		LightInfoBig current = lights[index];
		lightOut += ApplyLight(current, fragPosition, fragNormal, viewDirection);
	}
	return lightOut;
}