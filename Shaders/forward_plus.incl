layout(origin_upper_left) in vec4 gl_FragCoord;

float ConeRatio(Cone cone, vec3 forward)
{
	float angle = dot(cone.forward, -forward);
	// Flipping this does really neat things, if you transpose the normal and position in the cone light functions
	//return (cone.angle < angle) ? 1.f : 0.f;
	
	float temp = mix(cone.angle, 1.f, 0.5f);
	return smoothstep(cone.angle, temp, angle);
}

vec3 ConeLight(LightInfoBig light, FragData fragData)
{
	Cone cone = LightToCone(light);
	vec3 fragPosition  = fragData.position;
	vec3 fragNormal    = fragData.normal;
	vec3 viewDirection = fragData.viewDirection;
	
	vec3 lightDirection = normalize(cone.position - fragPosition);
	float distance = length(cone.position - fragPosition);
	
	// Do the attenuation thing
	float diffuse  = applyDiffuse(fragData, lightDirection);
	float specular = applySpecular(fragData, lightDirection);
	
	float fallOff = attenuate(light.constants.xyz, distance);
	
	if (length(dot((cone.position - fragPosition), -cone.forward)) > cone.height)
	{
		fallOff = 0.f;
	}
	
	return light.color.xyz * (diffuse + specular) * ConeRatio(cone, lightDirection) * fallOff;
}

vec3 DirectedLight(LightInfoBig light, FragData fragData)
{
	// This feels like an admission of defeat
	vec3 lightDirection = -light.direction.xyz;
	float diffuse  = applyDiffuse(fragData, lightDirection);
	float specular = applySpecular(fragData, lightDirection);
	return light.color.xyz * (diffuse + specular);
}

vec3 ApplyLight(LightInfoBig current, FragData fragData)
{
	vec3 lightOut = vec3(0);
	float type = current.position.w;
	// Point light
	if (type > 0)
	{
		lightOut += PointLightStruct(current, fragData);
	}
	// Light cone
	else if (type < 0)
	{
		lightOut += ConeLight(current, fragData);
	}
	else // Directed light
	{
		lightOut += DirectedLight(current, fragData);
	}
	return lightOut;
} 

vec3 ForwardPlusLighting(FragData fragData)
{
	const float ambient = 0.15;
	vec3 lightOut = vec3(ambient);

	vec2 index = floor((gl_FragCoord.xy) / TileSize);
	uint gridIndex = uint(index.x + index.y * tileDimension.x);
	
	const uint numLightsThisTile = tileMasks[gridIndex * MasksPerTile];
	uint processedLights = 0;
	
	// Possibly something with the bitCount() function to escape early if the number of lights remaining is zero
	uint firstMask = gridIndex * MasksPerTile + 1;
	for (uint i = 0; i + 1 < MasksPerTile && processedLights < numLightsThisTile; i++)
	{
		uint currentMask = tileMasks[i + firstMask];
		processedLights += bitCount(currentMask);
		while (currentMask != 0)
		{
			uint currentBit = findLSB(currentMask);
			currentMask ^= 1 << currentBit;
			
			LightInfoFull current = largestLights[32 * i + currentBit];
			lightOut += ApplyLight(GetWorldSpaceLighting(current), fragData);		
		}
	}
	return lightOut;
}

vec3 LightTesting()
{
	const float ambient = 0.15;
	vec3 lightOut = vec3(ambient);

	vec2 index = floor((gl_FragCoord.xy) / TileSize);
	uint gridIndex = uint(index.x + index.y * tileDimension.x);

	uint numLightsThisTile = tileMasks[gridIndex * MasksPerTile];
	
	if (numLightsThisTile > 10)
	{
		return ambient + vec3(0, 1.f, 0);
	}
	return ambient + vec3(numLightsThisTile / 10.f);
};

vec3 ForwardPlusLightingViewSpace(FragData fragData)
{
	const float ambient = 0.15;
	vec3 lightOut = vec3(ambient);

	vec2 index = floor((gl_FragCoord.xy) / TileSize);
	uint gridIndex = uint(index.x + index.y * tileDimension.x);
	
	const uint numLightsThisTile = tileMasks[gridIndex * MasksPerTile];
	uint processedLights = 0;
	
	// Possibly something with the bitCount() function to escape early if the number of lights remaining is zero
	uint firstMask = gridIndex * MasksPerTile + 1;
	for (uint i = 0; i + 1 < MasksPerTile && processedLights < numLightsThisTile; i++)
	{
		uint currentMask = tileMasks[i + firstMask];
		processedLights += bitCount(currentMask);
		while (currentMask != 0)
		{
			uint currentBit = findLSB(currentMask);
			currentMask ^= 1 << currentBit;
			
			LightInfoFull current = largestLights[32 * i + currentBit];
			lightOut += ApplyLight(GetViewSpaceLighting(current), fragData);
		}
	}
	return lightOut;
}