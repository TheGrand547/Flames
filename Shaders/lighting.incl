struct LightInfo
{
	vec4 position;
	vec4 color;
};


struct LightInfoBig
{
	// position.w determines whether it's a point light(>0), cone light(<0), or a directed light(else)
	vec4 position;
	vec4 color;
	// constants.w holds the bottom radius of the cone
	vec4 constants;
	// direction.w holds the cosine of cones half angle
	vec4 direction;
};

struct LightInfoFull
{
	// position.w determines whether it's a point light(>0), cone light(<0), or a directed light(else)
	vec4 position;
	vec4 positionViewSpace;
	vec4 color;
	// constants.w holds the bottom radius of the cone
	vec4 constants;
	// direction.w holds the cosine of cones half angle
	vec4 direction;
	vec4 directionViewSpace;
};


LightInfoBig GetWorldSpaceLighting(LightInfoFull info)
{
	LightInfoBig result;
	result.position = info.position;
	result.color = info.color;
	result.constants = info.constants;
	result.direction = info.direction;
	return result;
}

LightInfoBig GetViewSpaceLighting(LightInfoFull info)
{
	LightInfoBig result;
	result.position = info.positionViewSpace;
	result.color = info.color;
	result.constants = info.constants;
	result.direction = info.directionViewSpace;
	return result;
}


struct FragData
{
	vec3 position;
	vec3 normal;
	vec3 viewDirection;
	// TODO: Material stuff
};


float attenuate(vec3 constants, float distance)
{
	float falloff = constants.x + distance * constants.y + (distance * distance) * constants.z;
	return 1.f / falloff;
}

float applyDiffuse(FragData fragData, vec3 lightDirection)
{
	return max(dot(fragData.normal, lightDirection), 0);
}

float applySpecular(FragData fragData, vec3 lightDirection)
{
	vec3 reflection = reflect(-lightDirection, fragData.normal);
	float alignment = max(dot(fragData.viewDirection, reflection), 0.0);
	
	// Incorporate the material settings from the fragData
	return pow(alignment, 128);
}

vec3 DirectedLight(vec3 lightDirection, vec3 lightColor, FragData fragData)
{
	vec3 fragNormal    = fragData.normal;
	vec3 viewDirection = fragData.viewDirection;

	vec3 lightDir  = -lightDirection;
	float diffuse  = applyDiffuse(fragData, lightDir);
	float specular = applySpecular(fragData, lightDir);
	return lightColor * (specular + diffuse);
}

vec3 PointLight(vec3 lightPos, vec3 lightColor, FragData fragData)
{
	vec3 fragPosition  = fragData.position;
	vec3 fragNormal    = fragData.normal;
	vec3 viewDirection = fragData.viewDirection;
	
	vec3 lightDir  = normalize(lightPos - fragPosition);
	float distance = length(lightPos - fragPosition);
	float diffuse  = applyDiffuse(fragData, lightDir);
	float specular = applySpecular(fragData, lightDir);

	float fallOff = attenuate(vec3(1.f, 1.f/30.f, 0.002f), distance);
	return lightColor * (specular + diffuse) * fallOff;
}

vec3 PointLightConstants(vec3 lightPos, vec3 lightColor, vec3 lightConstants, FragData fragData)
{
	vec3 fragPosition  = fragData.position;
	vec3 fragNormal    = fragData.normal;
	vec3 viewDirection = fragData.viewDirection;
	
	vec3 lightDir  = normalize(lightPos - fragPosition);
	float distance = length(lightPos - fragPosition);
	float diffuse  = applyDiffuse(fragData, lightDir);
	float specular = applySpecular(fragData, lightDir);

	float fallOff = attenuate(lightConstants.xyz, distance); 
	return lightColor * (specular + diffuse) * fallOff;
}

vec3 PointLightStruct(LightInfoBig inputs, FragData fragData)
{
	if (length(inputs.position.xyz - fragData.position) < inputs.position.w)
	{
		return PointLightConstants(inputs.position.xyz, inputs.color.xyz, inputs.constants.xyz,  fragData);
	}
	return vec3(0);	
}

vec3 DirectedPointLight(vec3 lightPos, vec3 lightDirection, vec3 lightColor, FragData fragData)
{
	vec3 fragPosition  = fragData.position;
	vec3 fragNormal    = fragData.normal;
	vec3 viewDirection = fragData.viewDirection;
	
	vec3 lightDir  = normalize(lightPos - fragPosition);
	float distance = length(lightPos - fragPosition);
	
	float diffuse  = applyDiffuse(fragData, lightDir);
	float specular = applySpecular(fragData, lightDir);
	
	// Check how aligned the "primary" direction of the light is, with the light hitting this fragment
	float directed = abs(max(dot(lightDir, lightDirection), 0));
		
	float constant = cos(radians(25));
	// If the alignment is less than 25 degrees(arbitrary constant), the light has no effect
	
	// I don't know which of these I prefer
	float multiplier = step(constant, directed);
	multiplier *= (directed - constant) / ( 1 - constant);
	multiplier = pow(multiplier, 2);
	
	float fallOff = attenuate(vec3(1.f, 1.f / 50.0, 1.f / 100000.f), distance);
	return lightColor * (specular + diffuse) * fallOff * multiplier;
}